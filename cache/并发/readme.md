* 单线程的好处就是：

    无需像多线程那样去关注线程之间的状态同步问题
    没有线程切换所带来的开销
    没有死锁存在
    当然单线程也有许多坏处：

* 无法充分利用多核CPU
    大量计算占用CPU会导致应用阻塞(即不适用CPU密集型)
    错误会引起整个应用的退出
    不过在今天看来，这些坏处都已经不再是问题或者得到了适当的解决：

&&(1) 创建进程 or 细分实例

关于第一个问题，最直白解决方案就是使用child_process核心模块或者cluster：child_process 和 net 组合应用。我们可以通过在一台多核服务器上创建多个进程（通常使用fork操作）来充分利用每个核心，不过要处理好进程间通信问题。

另一个方案是，我们可以将物理机器划分为多台单核的虚拟机，并通过pm2等工具，管理多台虚拟机形成一个集群架构，高效运行所需服务。至于每台机器间的通信（状态同步）我这里先按下不表，在下文的Node分布式架构中再做详细说明。
(2) 时间片轮转

关于第二点，我跟小伙伴讨论过后认为可以通过时间片轮转方式，在单线程上模拟多线程，适当减少应用阻塞的感觉（虽然这种方法不会真的像多线程那样节约时间）
(3) 负载均衡、坏点监控/隔离

至于第三点，我跟小伙伴们也讨论过，认为主要的痛点就在于node不同于JAVA，它所实现的逻辑是以异步为主的。这就导致了node无法像JAVA一样方便地使用 try/catch 来来捕获并绕过错误，因为无法确定异步任务会何时传回异常。

而在单线程环境下，绕不过错误就意味着导致应用退出，重启恢复的间隙会导致服务中断，这是我们不愿意看到的。

当然，在服务器资源丰富的当下，我们可以通过 pm2 或 nginx 这些工具，动态的判断服务状态。在服务出错时隔离坏点服务器，将请求转发到正常服务器上，并重启坏点服务器以继续提供服务。这也是Node分布式架构的一部分。
不同进程并发运行（任务级并行）
## 关于并发
>并发是指两个或多个时间链随实践发展交替执行。就像是同时执行的。
进程1 onscroll
进程2 Ajax响应
>但他们的事件是在实践循环队列中一次进行的
## 并发线程的交互
>共享作用域，可以设置竟态条件。
## 并发线程的协作

## Promise 的一部特性基于任务的
## 回调方式的异步，中断风险，表达异步太复杂。
## 控制反转
//A
ajax("...",function(..){
    //c
})
//B
A，B发生在现在，C将来执行
ajax可能不是你编的代码，也不在你的控制之下，多数之下，它是第三方提供的工具
在你的代码和第三方工具这几件有一份并没有明确表达的契约
>回调不能一直被调用，创建阀门处理对回调到 的多个并发调用。
>回调引起控制反转的大量逻辑维护。控制反转就是新人但要核实，比如要做类型检查啊
>回调没有提供东西来支持这些校验的机制。导致新人链的完全断裂